<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"remimimiel.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="LeetCode春招学习计划I：时间复杂度与空间复杂度，技术面试考点汇总，数组，动态数组，二维数组的查找，二分查找">
<meta property="og:type" content="article">
<meta property="og:title" content="春招学习计划I">
<meta property="og:url" content="https://remimimiel.github.io/2021/01/22/%E6%98%A5%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92I/index.html">
<meta property="og:site_name" content="Remiel">
<meta property="og:description" content="LeetCode春招学习计划I：时间复杂度与空间复杂度，技术面试考点汇总，数组，动态数组，二维数组的查找，二分查找">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remimimiel.github.io/images/2021/22/春招学习计划I/1.png">
<meta property="og:image" content="https://remimimiel.github.io/images/2021/22/春招学习计划I/2.png">
<meta property="og:image" content="https://remimimiel.github.io/images/2021/22/春招学习计划I/3.png">
<meta property="og:image" content="https://remimimiel.github.io/images/2021/22/春招学习计划I/4.png">
<meta property="og:image" content="https://remimimiel.github.io/images/2021/22/春招学习计划I/5.png">
<meta property="og:image" content="https://remimimiel.github.io/images/2021/22/春招学习计划I/6.jpg">
<meta property="article:published_time" content="2021-01-22T08:24:11.000Z">
<meta property="article:modified_time" content="2021-01-24T02:22:51.661Z">
<meta property="article:author" content="Remiel">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="数据结构和算法">
<meta property="article:tag" content="数组操作，动态数组，二分查找">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remimimiel.github.io/images/2021/22/春招学习计划I/1.png">

<link rel="canonical" href="https://remimimiel.github.io/2021/01/22/%E6%98%A5%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92I/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>春招学习计划I | Remiel</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Remiel</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://remimimiel.github.io/2021/01/22/%E6%98%A5%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Remiel">
      <meta itemprop="description" content="Remiel's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Remiel">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          春招学习计划I
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-22 16:24:11" itemprop="dateCreated datePublished" datetime="2021-01-22T16:24:11+08:00">2021-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-24 10:22:51" itemprop="dateModified" datetime="2021-01-24T10:22:51+08:00">2021-01-24</time>
              </span>

          
            <div class="post-description">LeetCode春招学习计划I：时间复杂度与空间复杂度，技术面试考点汇总，数组，动态数组，二维数组的查找，二分查找</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="时间复杂度与空间复杂度">时间复杂度与空间复杂度</h1>
<h2 id="常见的时间复杂度计算规则">常见的时间复杂度计算规则</h2>
<h3 id="常数加法系数看做-0">1. 常数加法系数看做 0</h3>
<p>一段程序必须要做的操作（常数次操作）不纳入复杂度的计算。一般而言，常数次操作都不会是造成程序性能瓶颈的原因。</p>
<h3 id="对于一个多项式只保留最高次幂的项并且乘法系数化简成-1">2. 对于一个多项式，只保留最高次幂的项，并且乘法系数化简成 1</h3>
<p>常见结论：</p>
<ul>
<li>一次遍历，里面不再有循环的操作，时间复杂度是 <span class="math inline">\(O(N)\)</span>。也就是说，我们把输入数据里所有的元素看一遍，就可以得到结果。这样的算法称为具有线性复杂度的算法。</li>
<li>双重循环，内外层都与输入规模相关的时候，时间复杂度是 <span class="math inline">\(O(N^2)\)</span> 。 <span class="math inline">\(O(N^2)\)</span> 级别的复杂度我们会在第 3 章「选择排序」和「插入排序」章节向大家介绍。</li>
</ul>
<p>注意：有些算法形式上是双重循环，但事实上，程序只遍历了数组一次或者若干次，这样的算法时间复杂度为 <span class="math inline">\(O(N)\)</span> ，以后遇到这一类问题的时候再向大家说明。</p>
<h3 id="对数或者是含有对数乘法因子的项对数底都看作-2">3. 对数或者是含有对数乘法因子的项，对数底都看作 2</h3>
<p>对数级别的时间复杂度，常见且典型的算法是「二分查找」，时间复杂度的表达式为 <span class="math inline">\(O(logN)\)</span>。</p>
<p>下面我们介绍为什么底数都看成 2。如果一个算法计算出来的输入规模 <span class="math inline">\(N\)</span> 与算法执行次数的表达式为 <span class="math inline">\(log_{10}N\)</span> ，那么根据高中数学学习过的对数换底公式： <span class="math display">\[
log_ab=\frac{log_cb}{log_ca}
\]</span> 有 <span class="math inline">\(log_{10}N=\frac{log_2N}{log_210}=\frac1{log_210}log_2N\)</span>，常数乘法系数项 <span class="math inline">\(\frac1{log_210}\)</span> 视为1，因此写 <span class="math inline">\(O(log_{10}N)\)</span> 等价于 <span class="math inline">\(O(log_2N)\)</span>，统一记为 <span class="math inline">\(O(logN)\)</span>。</p>
<h2 id="绝大多数时候关注最坏情况">绝大多数时候关注最坏情况</h2>
<p>一个程序最坏的情况我们都可以接受，那么最好的情况当然是没有问题的，这就像我们常说的「做最好的准备，最坏的打算」一样。</p>
<p>当然也有例外：如果一个程序，我们采用了一些手段，导致了最坏情况出现的概率大大降低，那么我们会约定俗成地将时间复杂度定义成「一般情况」，也就是说「最坏情况」几乎不可能发生的话，我们就把「一般情况」当成「最坏情况」。</p>
<h2 id="总结">总结</h2>
<ol type="1">
<li>时间复杂度的概念很重要，除了一些复杂的算法，例如「带剪枝」的「回溯算法」，复杂度的分析很复杂，一般情况下不要求分析；</li>
<li>时间复杂度需要动态去理解，看到一个复杂度的表达式，我们需要想到：当输入规模扩大多少倍的时候，程序的执行时间相应扩大了多少倍；</li>
<li>对于时间复杂度的优化比空间复杂度重要得多；</li>
<li>复杂度分析还有「均摊复杂度分析」和「震荡时间复杂度分析」，我们遇到具体问题的时候再和大家做介绍；</li>
<li>复杂度分析还有一个非常重要的理论：「主定理」，我们也会在后续的课程里向大家介绍。</li>
</ol>
<h1 id="技术面试考点汇总">技术面试考点汇总</h1>
<p>力扣为大家汇总了互联网公司技术面试中经常考察的问题类型。</p>
<p>无论你是面试什么岗位，面试官基本都会从以下几个方面全面考察候选人的技术水平。当然，除了这些面试考点以外，你还需要了解目标岗位的其他技术要求，及时查漏补缺，充分备战技术面试。</p>
<p><img src="/images/2021/22/春招学习计划I/1.png"></p>
<p>算法和数据结构一直是技术面试的重点和难点。近年来，很多知名企业如谷歌, 脸书等在面试过程中都会有特定的电话面试环节, 专门用来面算法题。这些企业通常会使用在线协同代码编程网站，需要面试者用一小时解决 4 道算法问题，面试官可以实时看到候选人所写的代码。除了远程面试外, 在 Onsite 面试中还会有白板写代码等环节。</p>
<p>力扣也为各位技术求职者们总结了一张算法和数据结构的考点类型汇总图，大家可以根据思维导图里的内容进行系统地学习。</p>
<p><img src="/images/2021/22/春招学习计划I/2.png"></p>
<p>如果你对图中的知识点还不是很熟悉，可以先去力扣 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/">LeetBook</a> 进行主题练习，每个卡片都有对应的知识点讲解，可以帮助你快速入门。或者你也可以通过 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">题库页</a> 的题目标签进行专项练习，遇到不会的题目时可以先将这道题目「收藏」，然后去题解区看看其他用户的解题思路，在看题解时需做好笔记，思考哪个环节自己没有想到，及时调整自己的思路，亲自写出最优的解法，并趁热打铁多做几道类似的题目加以巩固。在准备面试时，也要预留一定的复习时间，这时候你就可以打开自己的收藏夹，再次巩固一下曾经不会的题目。</p>
<h1 id="数组">数组</h1>
<h2 id="数组的基本操作">数组的基本操作</h2>
<h3 id="读取元素">1. 读取元素</h3>
<h3 id="更新元素">2. 更新元素</h3>
<h3 id="插入元素">3. 插入元素</h3>
<ul>
<li><p>尾部插入：尾部插入，是最简单的情况，直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作。</p></li>
<li><p>中间插入：中间插入，稍微复杂一些。由于数组的每一个元素都有其固定下标，所以不得不首先把插入位置及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上。</p></li>
<li><p>超范围插入：假如现在有一个长度为 6 的数组，已经装满了元素，这时还想插入一个新元素。这就涉及数组的 <strong>扩容</strong> 了。此时可以创建一个新数组，长度是旧数组的 2 倍，再把旧数组中的元素统统复制过去，这样就实现了数组的扩容。</p></li>
</ul>
<p>以下是插入元素方法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyArray</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组插入元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index 插入的位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> element 插入的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//判断访问下标是否超出范围</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;size)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;超出数组实际元素范围！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果实际元素达到数组容量上限，则对数组进行扩容</span></span><br><span class="line">    <span class="keyword">if</span>(size &gt;= array.length)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从右向左循环，将元素逐个向右挪1位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size-<span class="number">1</span>; i&gt;=index; i--)&#123;</span><br><span class="line">        array[i+<span class="number">1</span>] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//腾出的位置放入新元素</span></span><br><span class="line">    array[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组扩容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arrayNew = <span class="keyword">new</span> <span class="keyword">int</span>[array.length*<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//从旧数组复制到新数组</span></span><br><span class="line">    System.arraycopy(array, <span class="number">0</span>, arrayNew, <span class="number">0</span>, array.length);</span><br><span class="line">    array = arrayNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MyArray myArray = <span class="keyword">new</span> MyArray(<span class="number">4</span>);</span><br><span class="line">    myArray.insert(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    myArray.insert(<span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line">    myArray.insert(<span class="number">2</span>,<span class="number">9</span>);</span><br><span class="line">    myArray.insert(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    myArray.insert(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">    myArray.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除元素">4. 删除元素</h3>
<p>数组的删除操作和插入操作的过程相反，如果删除的元素位于数组中间，其后的元素都需要向前挪动 1 位。</p>
<p>由于不涉及扩容问题，所以删除操作的代码实现比插入操作要简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组删除元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 删除的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//判断访问下标是否超出范围</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=size)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;超出数组实际元素范围！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> deletedElement = array[index];</span><br><span class="line">    <span class="comment">//从左向右循环，将元素逐个向左挪1位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;size-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        array[i] = array[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> deletedElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于删除操作，如果数组元素没有顺序要求，还有一种取巧的方式：将数组最后一个元素复制到删除的元素位置，然后再删除掉最后一个元素，这样时间复杂度为 <span class="math inline">\(O(1)\)</span>。</p>
<h1 id="数组理论">数组理论</h1>
<h2 id="数组定义">数组定义</h2>
<p>数组，可以直观地理解为一串连续的数据。<strong>数组在不同的语言中可能有不同的名字和特性</strong>：</p>
<ul>
<li>不同的名字：例如在 Python 中我们一般叫做 List ，在 C++ 中叫做 Vector 等。</li>
<li>不同的性质：在 C++ 等语言中数组中的元素要求是相同类型，不过 Python 中没有这种限制，我们可以有例如 [1,2,3]，[a,b,1] 等等这样的数组。</li>
</ul>
<p>从维度上来看，数组根据维度会分为一维数组和多维数组。一般就考察而言一维和二维数组的题目比较常见，不过多维数组也会出现在某些题目，尤其是 <strong>动态规划</strong> 类题目中。另外，如果熟悉深度学习的同学一定也不会对 Tensor，也就是张量这个词陌生，实际上深度学习框架中的张量本身就是一个多维的数组数据。</p>
<h2 id="数组的操作">数组的操作</h2>
<ul>
<li>遍历：通过循环访问数组中每个元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            array[i][j] = xxx</span><br></pre></td></tr></table></figure>
<ul>
<li>索引：常数时间内访问数组中随机元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[i][j] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>部分语言支持其他的一些操作特性，例如 Python 支持切片等，这里就不详细展开了。</p>
<h2 id="实现动态数组">实现动态数组</h2>
<p>不论是 C++ 的 Vector ，或者是 Python 的 List ，实际上都是 <strong>动态数组</strong>。所谓动态数组是长度可以动态改变的数组，而对应的是静态数组，容量不能随时改变。</p>
<p>对于计算机来说，静态数组是更容易理解的，因为可以直接分配一整块连续的内存。连续内存的意义在于可以更快地寻址与访问，满足数组的随机查找特性。而对于动态数组来说，理论上他的存储空间是无限的，取决于机器内存大小。但是难点是我们不能直接开始就申请内存总大小这么大的空间，这显然不合理。所以如何实现动态数组，使其既满足长度的动态改变，又不损失数组的随机查找效率，也是一件非常具有挑战性的事情。</p>
<h3 id="动态数组的操作需求">动态数组的操作需求</h3>
<p>我们先来思考一下一个数组需要有哪些操作：</p>
<ul>
<li><code>push_back</code>：首先，我们需要一个 <code>push_back</code> 函数，用于在最后插入一个新元素到数组中</li>
<li><code>pop_back</code>：我们还需要一个 <code>pop_back</code> 函数，对应地删除最后一个元素</li>
<li><code>size</code>：用于表示数组大小</li>
<li><code>index</code>：返回下标为 index 的数组元素</li>
</ul>
<p>当然，这里还有非常多其他的操作，例如删除中间某一个元素等等，这些操作可以用循环来实现，我们这里就不介绍了。这里仅介绍如何实现数组的基本功能。</p>
<h3 id="用静态数组实现动态数组">用静态数组实现动态数组</h3>
<p>刚才提到，实现动态数组的难点在于我们不知道我们的动态数组究竟需要多少空间。既然如此，我们可以先暂时申请一小段空间，例如 10，我们假定我们这个数组初始有 10 的空间。</p>
<p>申请好了以后，我们不断地往数组里插入数。那么 10 的空间都用完以后，我们现在插入的空间不够了，则可以申请一个长度为 (10*2, 也就是20) 的数组，然后同样拷贝插入。</p>
<blockquote>
<p>因为如果按第一种策略，每次插入一个元素都要重新申请一个长度为 <span class="math inline">\(n\)</span> 的数组，这样我们插入 <span class="math inline">\(n\)</span> 个元素时间复杂度是 <span class="math display">\[
1+2+……+n=(n+1)*n/2
\]</span> 也就是 <span class="math inline">\(O(n^2)\)</span> 的级别。</p>
<p>而如果每次我们将数组容量开大一倍的话，大家可以这么思考，假定我们最后的数组容量为 <span class="math inline">\(n\)</span> ，那么我们最后申请的是长度为 <span class="math inline">\(n\)</span> 的数组，上一次申请的是长度为 <span class="math inline">\(n/2\)</span> 的数组，再上一次是 <span class="math inline">\(n/4\)</span>，最终时间复杂度为 <span class="math inline">\(O(n)\)</span>。 <span class="math display">\[
n+n/2+n/4+……\le 2n
\]</span></p>
</blockquote>
<p>解决了内存分配的核心问题，我们就可以很轻松地给出这些操作的实现了：</p>
<ul>
<li><code>push_back</code>：判断当前数组大小是否已满，满了的话申请一个容量为之前两倍的数组，拷贝所有内容，然后插入新的数。</li>
<li><code>pop_back</code>：删除最后的元素，数组 size - 1。</li>
<li><code>size</code>：返回当前元素数量。</li>
<li><code>index</code>：直接返回下标为 index 的数组元素。</li>
</ul>
<h1 id="实现动态数组-1">实现动态数组</h1>
<p>请参照课程内容，用静态数组实现一个动态数组，包括：</p>
<ul>
<li><code>push_back(int n)</code> - 在数组末尾插入新元素 <code>n</code>，无需返回</li>
<li><code>pop_back()</code> - 删除数组中的最后一个元素，无需返回</li>
<li><code>size()</code> - 返回数组长度</li>
<li><code>index(int idx)</code>- 返回数组中下标为 <code>idx</code> 的元素</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;LCArray&quot;</span>, <span class="string">&quot;size&quot;</span>, <span class="string">&quot;push_back&quot;</span>, <span class="string">&quot;pop_back&quot;</span>, <span class="string">&quot;size&quot;</span>, <span class="string">&quot;push_back&quot;</span>, <span class="string">&quot;size&quot;</span>, <span class="string">&quot;index&quot;</span>, <span class="string">&quot;pop_back&quot;</span>, <span class="string">&quot;push_back&quot;</span>]</span><br><span class="line">[[], [], [<span class="number">95</span>], [], [], [<span class="number">37</span>], [], [<span class="number">0</span>], [], [<span class="number">28</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null,<span class="number">0</span>,null,null,<span class="number">0</span>,null,<span class="number">1</span>,<span class="number">37</span>,null,null]</span><br><span class="line">解释：</span><br><span class="line">LCArray l = LCArray()</span><br><span class="line">l.size()        <span class="comment">// 获取数组长度，此时数组为空，返回 0</span></span><br><span class="line">l.push_back(<span class="number">95</span>) <span class="comment">// 在数组末尾插入新元素 95，返回 null</span></span><br><span class="line">l.pop_back()    <span class="comment">// 删除数组中的最后一个元素，返回 null</span></span><br><span class="line">l.size()        <span class="comment">// 获取数组长度，此时数组为空，返回 0</span></span><br><span class="line">l.push_back(<span class="number">37</span>) <span class="comment">// 在数组末尾插入新元素 37，返回 null</span></span><br><span class="line">l.size()        <span class="comment">// 获取数组长度，返回 1</span></span><br><span class="line">l.index(<span class="number">0</span>)      <span class="comment">// 返回数组中下标为 0 的元素 37</span></span><br><span class="line">l.pop_back()    <span class="comment">// 删除数组中的最后一个元素，返回 null</span></span><br><span class="line">l.push_back(<span class="number">28</span>) <span class="comment">// 在数组末尾插入新元素 28，返回 null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>C++中new和delete用法：分配内存和释放内存 (多用于指针，数组) http://c.biancheng.net/view/206.html</li>
<li>构造函数和析构函数 http://c.biancheng.net/view/2221.html</li>
<li><code>memcpy()</code>与<code>memmove()</code> : <code>memcpy(dst,src,len*sizeof(int));</code> https://www.cnblogs.com/clwsec/p/11600899.html</li>
</ul>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LCArray()</span><br><span class="line">    &#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        capacity = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~LCArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz &gt;= capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            capacity *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">            memmove(tmp, <span class="built_in">array</span>, sz * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">            <span class="built_in">array</span> = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[sz] = n;</span><br><span class="line">        sz++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sz--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二维数组">二维数组</h1>
<p>二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。</p>
<p>所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 <code>0</code> 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。</p>
<p>类似一维数组，对于一个二维数组 <code>A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]</code>，计算机同样会在内存中申请一段 <strong>连续</strong> 的空间，并记录第一行数组的索引位置，即 <code>A[0][0]</code> 的内存地址，它的索引与内存地址的关系如下图所示。</p>
<p><img src="/images/2021/22/春招学习计划I/3.png"></p>
<p>注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 <code>1</code>。实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。</p>
<h1 id="剑指-offer-04.-二维数组中的查找">剑指 Offer 04. 二维数组中的查找</h1>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong></p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target = <code>5</code>，返回 <code>true</code>。</p>
<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong></p>
<p><code>0 &lt;= n &lt;= 1000</code></p>
<p><code>0 &lt;= m &lt;= 1000</code></p>
<h2 id="解题方案">解题方案</h2>
<h3 id="思路">思路</h3>
<ul>
<li>标签：数组遍历</li>
<li>从矩阵的左下角看，上方的数字都比其小，右方的数字都比其大，所以依据该规律去判断数字是否存在</li>
<li>设当前数字为 <code>cur</code>，目标数字为 <code>target</code>，当 <code>target</code> &lt; <code>cur</code> 时，<code>cur</code> 更新为其上面的数字，当<code>target</code> &gt; <code>cur</code> 时，<code>cur</code> 更新为其右侧的数字，直到相等则返回 <code>true</code>，否则到了矩阵边界返回 <code>false</code></li>
<li>时间复杂度：<span class="math inline">\(O(m+n)\)</span></li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 从左下角开始找</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = matrix[row][col];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; cur)</span><br><span class="line">                row--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; cur)</span><br><span class="line">                col++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="画解">画解</h3>
<p><img src="/images/2021/22/春招学习计划I/4.png"></p>
<p>转载自https://leetcode-cn.com/leetbook/read/illustrate-lcof/xz2hh7/</p>
<h1 id="二分查找">二分查找</h1>
<h2 id="它是如何工作的">它是如何工作的？</h2>
<p>在最简单的形式中，二分查找对具有指定左索引和右索引的连续序列进行操作。这就是所谓的查找空间。二分查找维护查找空间的左、右和中间指示符，并比较查找目标或将查找条件应用于集合的中间值；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查以空的一半结束，则无法满足条件，并且无法找到目标。</p>
<p>在接下来的章节中，我们将回顾如何识别二分查找问题，“为什么我们使用二分查找” 这一问题的原因，以及你以前可能不知道的 3 个不同的二分查找模板。由于二分查找是一个常见的面试主题，我们还将练习问题按不同的模板进行分类，以便你可以在实践使用到每一个。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>二进制搜索可以采用许多替代形式，并且可能并不总是直接搜索特定值。有时您希望应用特定条件或规则来确定接下来要搜索的哪一侧（左侧或右侧）。</p>
</blockquote>
<p>我们将在接下来的章节中提供一些例子。</p>
<h2 id="二分查找-1">二分查找</h2>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol type="1">
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找模板分析">二分查找模板分析</h2>
<h3 id="模板说明">模板说明：</h3>
<p>你在网上看到的 99% 的二分查找问题会归结于这 3 个模板中的一个。有些问题可以使用多个模板来实现，但是当你做更多的练习时，你会注意到一些模板比其他模板更适合某些问题。</p>
<p><strong>注意：</strong>模板和它们的差异已被彩色标注如下。</p>
<p><img src="/images/2021/22/春招学习计划I/5.png"></p>
<p>这 3 个模板的不同之处在于：</p>
<ul>
<li>左、中、右索引的分配。</li>
<li>循环或递归终止条件。</li>
<li>后处理的必要性。</li>
</ul>
<p>模板 #1 和 #3 是最常用的，几乎所有二分查找问题都可以用其中之一轻松实现。模板 #2 更 高级一些，用于解决某些类型的问题。</p>
<p>这 3 个模板中的每一个都提供了一个特定的用例：</p>
<p><strong>模板 #1</strong> <code>(left &lt;= right)</code></p>
<ul>
<li>二分查找的最基础和最基本的形式。</li>
<li>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。</li>
<li>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li>
</ul>
<p><strong>模板 #2</strong> <code>(left &lt; right)</code></p>
<ul>
<li>一种实现二分查找的高级方法。</li>
<li>查找条件需要访问元素的直接右邻居。</li>
<li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li>
<li>保证查找空间在每一步中至少有 2 个元素。</li>
<li>需要进行后处理（处理一个元素 <span class="math inline">\(left\)</span>）。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</li>
</ul>
<p><strong>模板 #3</strong> <code>(left + 1 &lt; right)</code></p>
<ul>
<li>实现二分查找的另一种方法。</li>
<li>搜索条件需要访问元素的直接左右邻居。</li>
<li>使用元素的邻居来确定它是向右还是向左。</li>
<li>保证查找空间在每个步骤中至少有 3 个元素。</li>
<li>需要进行后处理（处理 <span class="math inline">\(left\)</span> 和 <span class="math inline">\(right\)</span>）。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li>
</ul>
<p><strong>时间和空间复杂度：</strong></p>
<p><strong>时间：</strong><code>O(log n)</code> —— 算法时间</p>
<p>因为二分查找是通过对查找空间中间的值应用一个条件来操作的，并因此将查找空间折半，在更糟糕的情况下，我们将不得不进行 O(log n) 次比较，其中 n 是集合中元素的数目。</p>
<p><strong>空间：</strong><code>O(1)</code> —— 常量空间</p>
<p>虽然二分查找确实需要跟踪 3 个指标，但迭代解决方案通常不需要任何其他额外空间，并且可以直接应用于集合本身，因此需要 <code>O(1)</code> 或常量空间。</p>
<h2 id="二分查找的典型问题一二分下标">二分查找的典型问题（一）：二分下标</h2>
<p>转载自<a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xs1z3v/">LeetCode</a></p>
<p>这一节我们来看「基本二分查找」问题的变形问题。「二分下标」是指在一个有序数组（该条件可以适当放宽）中查找目标元素的下标。这一节我们看两个问题。</p>
<h3 id="例-1力扣第-35-题搜索插入位置">例 1：「力扣」第 35 题：搜索插入位置</h3>
<p><strong>分析</strong>：这道题要求我们在一个有序数组里查找插入元素的位置，那么什么是插入元素的位置呢？我们看示例。</p>
<p>示例 1：目标元素 55 在有序数组 [1,3,5,6] 里，下标为 2，输出 2；</p>
<p>示例 2：目标元素 2 不在有序数组 [1,3,5,6] 里，返回 3 的下标 1 ，我们可以知道，如果数组中不存在目标元素，返回第 1 个严格大于目标元素的数值的下标；</p>
<p>示例 3：目标元素 7 不在有序数组 [1,3,5,6] 里。特别地，7 比最后一个元素 6 还大，返回最后一个元素的下标 +1；</p>
<p>示例 4：目标元素 0 不在有序数组 [1,3,5,6] 里。特别地，0 比第一个元素 1 还小，返回第 1 个元素的下标 0。</p>
<p>由上面 4 个示例，知道题目要我们找的是 <strong>大于等于目标元素的第 1 个下标</strong>。</p>
<p><strong>参考代码1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 题目没有说输入数组的长度可能为 0，因此需要做特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在区间 [left, right] 查找插入元素的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于程序走到这里 [left, right] 里一定存在插入元素的位置</span></span><br><span class="line">        <span class="comment">// 且退出循环的时候一定有 left == right 成立，因此返回 left 或者 right 均可</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答可见下一题<code>searchFirstPosition(nums, target);</code>部分，思路相同。</p>
<p>由于下标 <code>len</code> 这个位置，也有可能是插入元素的位置，于是可以省去最开始的特殊判断，通过两边 <strong>逼近</strong> 的方式找到插入元素的位置。</p>
<p><strong>参考代码 2</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 题目没有说输入数组的长度可能为 0，因此需要做特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在区间 [left, right] 查找插入元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意：这里初始值设置为 len，表示 len 这个下标也有可能是插入元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> right = len;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于程序走到这里 [left, right] 里一定存在插入元素的位置</span></span><br><span class="line">        <span class="comment">// 且退出循环的时候一定有 left == right 成立，因此返回 left 或者 right 均可</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>友情提示：希望大家通过这两版代码小小的差别，体会二分查找的思路 2 是如何通过<strong>两边向中间夹，逐渐逼近</strong>的方式找到目标元素。</p>
</blockquote>
<h3 id="例-2力扣第-34-题在排序数组中查找元素的第一个和最后一个位置">例 2：「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置</h3>
<p><strong>分析</strong>：这道题要求我们在一个有序的数组中找到和目标元素相等的元素的第一个位置和最后一个位置。</p>
<p>暴力解法在最坏情况下需要遍历数组一遍，时间复杂度为 O(N) ，我们就不具体介绍这种做法了。</p>
<p>比较容易想到的做法是：当我们取中间数发现它等于目标元素的时候，马上线性地向左边逐个检查，找到和目标元素相等的元素的第 1 个位置，然后再线性地向右边逐个检查，找到和目标元素相等的元素的最后一个位置。这样代码的时间复杂度就又变成线性的了。一个更好的做法是，当看到元素和目标元素相等的时候，继续二分去查找两个边界的下标。</p>
<p>首先，我们写出代码的「框架」，然后再去实现具体的「二分查找」子函数的逻辑。</p>
<blockquote>
<p>友情提示：写模块化的代码是程序员的基本素养，写代码的时候需要保证主线逻辑清晰，增强可读性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstPosition = searchFirstPosition(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (firstPosition == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能走到这里，一定是数组中存在目标元素</span></span><br><span class="line">        <span class="keyword">int</span> lastPosition = searchLastPosition(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPosition, lastPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：首先做一次特殊判断，当数组的长度为 0 的时候，按照题意返回 <code>[-1, -1]</code>。</p>
<p>我们先查找目标值在数组中的第 1 次出现的位置，如果目标值在数组中不存在，可以直接返回 <code>[-1, -1]</code>，否则继续寻找目标值在数组中的最后一次出现的位置。</p>
<p>我们这样写的思路是：能执行到 <code>searchLastPosition()</code> 方法，则说明目标元素在有序数组中一定存在，请大家思考这是为什么。</p>
<p>接下来编写 <code>searchFirstPosition(nums, target);</code> 这个方法。</p>
<p>首先分别设置 <code>left</code> 和 <code>right</code> 的初始值，这里 <code>left = 0</code> 和 <code>right = len - 1</code>，表示在 <code>[0, len - 1]</code> 左闭右闭这个范围内搜索目标元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>然后写上 <code>while (left &lt; right)</code>，在循环体内先写上 <code>int mid = (left + right) / 2;</code> 。下面的分析是很关键的。我们把搜索区间 <code>[left, right]</code> 分为两个部分：</p>
<p>如果看到的 <code>mid</code> 位置的元素的值严格小于 <code>target</code> 的话，那么 <code>mid</code> 以及 <code>mid</code> 的左边的所有元素一定不存在目标元素，因此下一轮搜索的区间是 <code>[mid + 1, right]</code>，此时我们将左边界设置为 <code>mid + 1</code>，即<code>left = mid + 1</code>；</p>
<p>然后是另一个分支，此时我们不单独做等于 <code>target</code> 的判断，把剩下的情况归为一类：</p>
<p>如果看到的 <code>mid</code> 位置的元素大于等于 <code>target</code> 的话，</p>
<p>如果 <code>mid</code> 位置的元素的值等于目标元素。 请注意，此时 <code>mid</code> 有可能是第 1 个等于目标元素的位置，也有可能不是。如果它不是第 1 个等于目标元素的位置，真正的第 1 个等于目标元素的位置应该在它的左边，同时，<code>mid</code>的右边一定不是目标元素第 1 次出现的位置，因此下一轮搜索的区间是 <code>[left, mid]</code>，此时我们将右边界设置为 <code>mid</code>，即 <code>right = mid</code>。</p>
<p>如果 <code>mid</code> 位置的元素的值不等于目标元素，即严格大于目标元素的值，那么下一轮搜索的区间是 <code>[left, mid - 1]</code>，我们不单独做这个判断，因为这个区间包含在子区间 <code>[left, mid]</code> 中，这两个区间内只相差 <code>mid</code>这一个元素。</p>
<p>事实上，你只要非常确定第 1 个分支的逻辑是正确的话，第 2 个分支就不用分析了，因为第一个分支得到的结论是下一轮在 <code>[mid + 1, right]</code> 里查找，那么第 2 个分支是第 1 个分支的反面，就一定在剩下的区间<code>[left, mid]</code> 里查找，因此需要把 <code>right</code> 移动到 <code>mid</code> 的位置。</p>
<p>在退出循环的时候，一定有 <code>left</code> 和 <code>right</code> 相等，但是这个位置上的元素是否等于目标元素，还需要单独做一次判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// mid 以及 mid 的左边一定不是目标元素第 1 次出现的位置</span></span><br><span class="line">            <span class="comment">// 下一轮搜索的区间是 [mid + 1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下一轮搜索的区间是 [left, mid]</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是第 1 个方法。接下来我们看一下第 2 个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// mid 以及 mid 的右边一定不是目标元素最后一次出现的位置</span></span><br><span class="line">            <span class="comment">// 下一轮搜索的区间是 [left, mid - 1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下一轮搜索的区间是 [mid, right]</span></span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：此时退出循环的时候不用判断，直接返回 <code>left</code> 或者 <code>right</code> 即可，因为根据逻辑，能走到这个方法的话，目标元素在数组中一定存在。如果不存在的话，在主函数里就直接返回 <code>[-1, -1]</code> 也就走不到这个方法了。</p>
<p>我们当然可以再判断一次，只是这一步操作没有必要，这一点是二分查找算法思路 2 的写法可以稍微偷懒的地方。此时如果我们马上提交代码，会看到我们写的代码「超出时间限制」，而且是这么小规模的测试用例。</p>
<p><img src="/images/2021/22/春招学习计划I/6.jpg"></p>
<p>这就说明我们有可能写了一个死循环。事实上，问题出在第 2 个方法，在取中间数的时候，应该加上 1。加上 1 以后，马上就得到了一个「通过」。原因我们再复习一下：当区间只剩下 2 个元素的时候，一旦进入 <code>left = mid;</code> 这个分支，下一轮搜索的区间不能缩小，这样无休止的进行下去，结果是死循环。解决的方法很简单，在取中间数的时候上取整。</p>
<p>当我们将中间数的写法写成 <code>int mid = (left + right + 1) / 2;</code> ，并且搜索区间只剩下 2 个元素的时候，我们再审视一下两个分支逻辑：</p>
<ul>
<li>如果进入第 1 个分支，<code>right = mid - 1;</code> 把右边界向左移动一位，此时 <code>left == right</code> 成立，退出循环；</li>
<li>如果进入第 2 个分支，<code>left = mid;</code> 把左边界向右移动到 <code>mid</code>，同样也有 <code>left == right</code> 成立，退出循环。</li>
</ul>
<p>二分查找算法每一轮搜索都必须使得搜索区间的长度收缩，直到为 11。因此，需要<strong>特别注意</strong>的情况就是，当分支的逻辑是 <code>left = mid</code> 和 <code>right = mid - 1</code> 的时候，在取中间数的时候取靠右边的中间数，在计算上向上取整即可。</p>
<p>我们再来看 <code>searchFirstPosition()</code> 方法为什么可行，还是看区间只有 2 个元素的时候。由于 <code>int mid = left + (right - left) / 2;</code> 此时 <code>mid = left</code> ，于是：</p>
<ul>
<li>如果进入第 1 个分支，<code>left = mid + 1;</code> 把左边界向右移动一位，此时 <code>left == right</code> 成立，退出循环；</li>
<li>如果进入第 2 个分支，<code>right = mid</code> 把右边界向左移动到 <code>mid</code>，同样也有 <code>left == right</code> 成立，退出循环。</li>
</ul>
<p><strong><em>因此，我们只需要记住一个结论：当看到分支是 <code>left = mid;</code> 和 <code>right = mid - 1;</code> 的时候，在计算中间数的索引的时候要向上取整。</em></strong></p>
<p>最后我们再强调一下编写分支逻辑的小技巧。可以考虑把 <code>mid</code> 所在元素排除的思路来，也就是先想想，<code>mid</code>在什么情况下一定不是我们想要查找的元素。原因是，排除的逻辑更简单，不太容易出错。</p>
<blockquote>
<p>友情提示：如果要查找的目标元素的逻辑需要同时满足的逻辑较多，「排除法」只需要对其中一个逻辑取反，就能将目标元素的待搜索区间进行缩减。</p>
</blockquote>
<p>因此，我们在编写的时候，常常把 <code>left = mid + 1;</code> 和 <code>right = mid - 1;</code> 作为第 1 个分支的逻辑（也有例外）。第 1 个分支写对的前提下，第 2 个分支就不用考虑了，取反面区间就好。完整代码如下。</p>
<p><strong>参考代码 3</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstPosition = searchFirstPosition(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (firstPosition == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能走到这里，一定是数组中存在目标元素</span></span><br><span class="line">        <span class="keyword">int</span> lastPosition = searchLastPosition(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPosition, lastPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchLastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;	<span class="comment">// 向上取整</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="comment">// mid 以及 mid 的右边一定不是目标元素最后一次出现的位置</span></span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [mid, right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchFirstPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;	<span class="comment">// 向下取整</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// mid 以及 mid 的左边一定不是目标元素第 1 次出现的位置</span></span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习">练习</h3>
<p>使用二分查找算法的思路 2 完成如下二分查找法问题：</p>
<ol type="1">
<li>完成「力扣」第 704 题：二分查找；</li>
<li>完成「力扣」第 153 题：寻找旋转排序数组中的最小值；</li>
<li>完成「力扣」第 154 题：寻找旋转排序数组中的最小值 II；</li>
<li>完成「力扣」第 33 题：搜索旋转排序数组；</li>
<li>完成「力扣」第 81 题：搜索旋转排序数组 II；</li>
<li>完成「力扣」第 278 题：第一个错误的版本；</li>
<li>完成「力扣」第 374 题：猜数字大小；</li>
<li>完成「力扣」第 852 题：山脉数组的峰顶索引；</li>
<li>完成「力扣」第 1095 题：山脉数组中查找目标值；</li>
<li>完成「力扣」第 4 题：寻找两个正序数组的中位数。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构和算法</a>
              <a href="/tags/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag"># 数组操作，动态数组，二分查找</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/06/ComputerVision-Lec08-ImageClassification/" rel="prev" title="ComputerVision_Lec08_ImageClassification">
      <i class="fa fa-chevron-left"></i> ComputerVision_Lec08_ImageClassification
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/23/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/" rel="next" title="x的平方根">
      x的平方根 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">时间复杂度与空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99"><span class="nav-number">1.1.</span> <span class="nav-text">常见的时间复杂度计算规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E6%95%B0%E5%8A%A0%E6%B3%95%E7%B3%BB%E6%95%B0%E7%9C%8B%E5%81%9A-0"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 常数加法系数看做 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%AA%E4%BF%9D%E7%95%99%E6%9C%80%E9%AB%98%E6%AC%A1%E5%B9%82%E7%9A%84%E9%A1%B9%E5%B9%B6%E4%B8%94%E4%B9%98%E6%B3%95%E7%B3%BB%E6%95%B0%E5%8C%96%E7%AE%80%E6%88%90-1"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 对于一个多项式，只保留最高次幂的项，并且乘法系数化简成 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E6%88%96%E8%80%85%E6%98%AF%E5%90%AB%E6%9C%89%E5%AF%B9%E6%95%B0%E4%B9%98%E6%B3%95%E5%9B%A0%E5%AD%90%E7%9A%84%E9%A1%B9%E5%AF%B9%E6%95%B0%E5%BA%95%E9%83%BD%E7%9C%8B%E4%BD%9C-2"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 对数或者是含有对数乘法因子的项，对数底都看作 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%97%B6%E5%80%99%E5%85%B3%E6%B3%A8%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5"><span class="nav-number">1.2.</span> <span class="nav-text">绝大多数时候关注最坏情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E6%B1%87%E6%80%BB"><span class="nav-number">2.</span> <span class="nav-text">技术面试考点汇总</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">数组的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. 读取元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.2.</span> <span class="nav-text">2. 更新元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.3.</span> <span class="nav-text">3. 插入元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.4.</span> <span class="nav-text">4. 删除元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA"><span class="nav-number">4.</span> <span class="nav-text">数组理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">数组定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text">数组的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">4.3.</span> <span class="nav-text">实现动态数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9C%80%E6%B1%82"><span class="nav-number">4.3.1.</span> <span class="nav-text">动态数组的操作需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">4.3.2.</span> <span class="nav-text">用静态数组实现动态数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-1"><span class="nav-number">5.</span> <span class="nav-text">实现动态数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">6.</span> <span class="nav-text">二维数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">7.</span> <span class="nav-text">剑指 Offer 04. 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%A1%88"><span class="nav-number">7.1.</span> <span class="nav-text">解题方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">7.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">7.1.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%BB%E8%A7%A3"><span class="nav-number">7.1.3.</span> <span class="nav-text">画解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">8.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-number">8.1.</span> <span class="nav-text">它是如何工作的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="nav-number">8.2.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF%E5%88%86%E6%9E%90"><span class="nav-number">8.3.</span> <span class="nav-text">二分查找模板分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%B4%E6%98%8E"><span class="nav-number">8.3.1.</span> <span class="nav-text">模板说明：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98%E4%B8%80%E4%BA%8C%E5%88%86%E4%B8%8B%E6%A0%87"><span class="nav-number">8.4.</span> <span class="nav-text">二分查找的典型问题（一）：二分下标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B-1%E5%8A%9B%E6%89%A3%E7%AC%AC-35-%E9%A2%98%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-number">8.4.1.</span> <span class="nav-text">例 1：「力扣」第 35 题：搜索插入位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B-2%E5%8A%9B%E6%89%A3%E7%AC%AC-34-%E9%A2%98%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">8.4.2.</span> <span class="nav-text">例 2：「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-number">8.4.3.</span> <span class="nav-text">练习</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Remiel</p>
  <div class="site-description" itemprop="description">Remiel's blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Remiel</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
